<!DOCTYPE HTML>
<html lang='en'>
<head>
 <title> audio test </title>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
 <link rel='stylesheet' type='text/css' href='default.css'/>
</head>

<!-- TO DO
  x draw zoom box on main waveform display
  x make zoom box slideable or pan in zoom waveform?
  x better zoom in/out buttons
  - vertical scale on FFT
  x logy option on FFT
  ? zoomable/slidable FFT with better buttons
-->

<body>
<h1> SPECTRA FROM THE MICROPHONE </h1>

<div style="visibility:hidden">
Input play-through monitoring:
<audio id="playthru" autoplay controls muted="true"></audio>
</div>

sampled audio:<br/>
<audio id="sampled" controls type="audio/mpeg"></audio><br/>
<input id="record" type="button" value="hold to record"/>
<a id="save" href="#" style="visibility:hidden">save</a>


<div id="wavecanvas"><canvas id="waveform" height="150" width="1000"></canvas></div>
<div>
  <input id="zoomin" type="button" value="zoom in"/>
  <input id="zoomout" type="button" value="zoom out"/>
</div>

<div id="zoomcanvas"><canvas id="wavezoom" height="150" width="1000"></canvas></div>
<p> <label for="zoomstart">zoom start</label><input id="zoomstart" type="number" value="3000" step="1000"/> </p>
<p> <label for="fftexp">zoom width</label><input id="fftexp" type="number" value="11"/> </p>

<div id="fftcanvas"><canvas id="wavefft" height="150" width="1000"></canvas></div>
<p> <label for="logtoggle">log scale</label><input id="logtoggle" type="checkbox"/> </p>
<p> <label for="freqmin">min frequency</label><input id="freqmin" type="number" value="0" step="200"/> </p>
<p> <label for="freqmax">max frequency</label><input id="freqmax" type="number" value="15000" step="200"/> </p>
<p> <label for="guidetoggle">harmonic guides</label><input id="guidetoggle" type="checkbox"/> </p>
<p> <label for="guidefreq">guide frequency</label><input id="guidefreq" type="number" value="512" step="100"/></p>
<hr/>

<div id="logdiv" style="visibility:hidden">
output log:<br>
</div>

<!-- end HTML portion -->

<script src="fft2.js"></script>
<script src="audiorecorder.js"></script>
<script type="text/javascript">

CanvasRenderingContext2D.prototype.clear = function() {
  this.fillStyle = "#fafafa";
  this.fillRect(0,0,this.canvas.width, this.canvas.height);
  this.strokeStyle = "#5a5a5a";
}
CanvasRenderingContext2D.prototype.labelText = function(text, x, y) {
  this.font = "8px Arial";
  this.fillStyle = "black";
  this.textAlign = "center";
  this.fillText(text, x, y);
}

var waveCtx = waveform.getContext("2d");
var zoomCtx = wavezoom.getContext("2d");
var fftCtx = wavefft.getContext("2d");
var aCtx = new AudioContext();
// the scriptnode never actually outputs anything, but the AudioNode graph needs to be connected
// or no processing happens
var scriptnode = aCtx.createScriptProcessor(512,1,1);
var gainnode = aCtx.createGain();
var recordingState = false;
var rawdata = new Float32Array(44100*30);
rawindex = 0;

waveCtx.clear(); zoomCtx.clear(); fftCtx.clear();

navigator.mediaDevices.getUserMedia({ video: false, audio: true })
  .then(function(s) {
    playthru.srcObject = s;
    source = aCtx.createMediaStreamSource(s);
    source.connect(scriptnode);
    scriptnode.connect(gainnode);
    gainnode.gain.value = 0;
    gainnode.connect(aCtx.destination);
    mediaRecorder = new MediaRecorder(s);
    chunks = [];
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
  }
)
  .catch(e => log(e.name + ": "+ e.message));

var log = msg => logdiv.innerHTML += msg + "<br/>";

scriptnode.onaudioprocess = function(procEvent) {
  var inputBuf = procEvent.inputBuffer;
  var indata = inputBuf.getChannelData(0);
  if (recordingState) {
    for (var i=0; i<inputBuf.length; i++) {
      rawdata[rawindex+i] = indata[i];
    }
    rawindex += inputBuf.length;
  }
}

document.getElementById("record").onmousedown = function() {
  log("mousedown on record");
  rawdata.fill(0);
  rawindex = 0;
  mediaRecorder.start();
  recordingState = true;
};

document.getElementById("record").onmouseup = function() {
  log("mouseup on record");
  mediaRecorder.stop();
  recordingState = false;
  // do stuff with rawdata
  zoomUpdate();
  // do stuff with mediaRecorder chunks
  blob = new Blob(chunks, {'type':'audio/mpeg'});
  chunks = []; // clear chunks for next recording
  sampled.src = window.URL.createObjectURL(blob);
  sampled.load();
  // make save available
  var dataview = encodeMonoWAV(rawdata.slice(0,rawindex));
  var audioBlob = new Blob([dataview], { type: "audio/wav" });
  var url = (window.URL || window.webkitURL).createObjectURL(audioBlob);
  var link = document.getElementById("save");
  link.style="visibility:visible";
  link.href = url;
  link.download = 'output.wav';
};

document.getElementById("zoomin").onclick = () => {fftexp.value -= 1; zoomUpdate()};
document.getElementById("zoomout").onclick = () => {fftexp.value -= -1; zoomUpdate()};
document.getElementById("zoomstart").onchange = zoomUpdate;
document.getElementById("fftexp").onchange = zoomUpdate;
document.getElementById("freqmin").onchange = zoomUpdate;
document.getElementById("freqmax").onchange = zoomUpdate;
document.getElementById("logtoggle").onchange = zoomUpdate;
document.getElementById("guidetoggle").onchange = zoomUpdate;
document.getElementById("guidefreq").onchange = zoomUpdate;

waveform.addEventListener("mousedown", function(evt) {
  var mousePos = getMousePos(waveform, evt);
  zoomstart.value = Math.round(mousePos.x * rawindex);
  zoomUpdate();
}, false)

function zoomUpdate() {
  var zoomend = Number(zoomstart.value) + 2**fftexp.value;
  drawWaveform(waveCtx, rawdata.slice(0,rawindex), 0, rawindex);
  drawZoombox(waveCtx, zoomstart.value/rawindex, zoomend/rawindex);
  drawWaveform(zoomCtx, rawdata.slice(zoomstart.value, zoomend), Number(zoomstart.value), zoomend);
  fftchunk = rawdata.slice(zoomstart.value, zoomend);
  doPowspec(fftchunk);
  drawWavespec(fftCtx, fftchunk);
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: (evt.clientX - rect.left)/canvas.width,
    y: (evt.clientY - rect.top)/canvas.height
  };
}

function doPowspec(real) {
  var imag = real.slice(0);
  imag.fill(0);
  fft2(real,imag);
  for (var i=0; i<real.length; i++) {
    real[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
  }
}

function drawWavespec(cx, d) {
  var df = aCtx.sampleRate / (2**fftexp.value);
  var fftmax = freqmax.value / df;
  var fftmin = freqmin.value / df;
  var plotted = d.slice(fftmin, fftmax);
  var h = cx.canvas.height;
  var w = cx.canvas.width;
  cx.clear();
  cx.beginPath();
  var scaley = h * 0.95 / Math.max(...plotted);
  var scalex = w / plotted.length;
  if (logtoggle.checked) {
    var logmax = Math.log10(Math.max(...plotted));
    var logmin = -3.0;
    for (var i=0; i<plotted.length; i++) {
      cx.lineTo(scalex*i, h*(0.95 - 0.95*(Math.log10(plotted[i]) - logmin)/(logmax-logmin)));
    }
  } else {
    for (var i=0; i<plotted.length; i++) {
      cx.lineTo(scalex*i, h*0.95 - scaley*plotted[i]);
    }
  }
  cx.stroke();
  cx.closePath();
  if (guidetoggle.checked) {
    var freq, x;
    cx.beginPath();
    for (var i=1; i<64; i++) {
      freq = i*guidefreq.value;
      x = (freq - freqmin.value) / (freqmax.value - freqmin.value);
      cx.moveTo(x*w, h/2 - h*0.03*(2 + 3*(i == 1) + (i%4 == 0)));
      cx.lineTo(x*w, h/2 + h*0.03*(2 + 3*(i == 1) + (i%4 == 0)));
    }
    cx.strokeStyle = "#f00";
    cx.stroke();
    cx.closePath();
  }
  for (var i=0.05; i<1; i+=0.1) {
    var freq = Math.round((fftmin + i*(fftmax-fftmin))*df);
    cx.labelText(freq + " Hz", w * i, h);
  }
}

function drawZoombox(cx, a, b) {
  var h = cx.canvas.height;
  var w = cx.canvas.width;
  cx.beginPath();
  cx.strokeStyle = "#4285f4";
  cx.rect(a*w, 10, (b-a)*w, h-20)
  cx.rect(a*w-2, 10, (b-a)*w+2, h-20)
  cx.stroke();
}

function drawWaveform(cx, d, a, b) {
  var h = cx.canvas.height;
  var w = cx.canvas.width;
  cx.clear();
  cx.beginPath();
  cx.moveTo(0,h/2);
  var scaley = (h/2) / absmax(d);
  var scalex = w / d.length;
  for (var i=0; i<d.length; i++) {
    cx.lineTo(scalex*i, h/2-scaley*d[i]);
  }
  cx.stroke();
  cx.closePath();
  for (var i=0.05; i<1; i+=0.1) {
    var time = Math.round(a + (b-a)*i);
    cx.labelText(time, w*i, h);
  }
}

// this is to get around "call stack size exceeded" errors from the simpler ... notation
function absmax(d) {
  var max = 0;
  for (var i=0; i<d.length; i++) {
    if (Math.abs(d[i]) > max) max = Math.abs(d[i]);
  }
  return max;
}

</script>

</body>
</html>
